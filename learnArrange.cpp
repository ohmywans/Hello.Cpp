// <<<<<배열의 선언과 규칙>>>>>

#include <iostream>

using namespace std;

int main() {

   /*
   C++는 복합 데이터형을 제공한다.
   >> 사용자 정의대로 새로운 데이터형을 만들 수 있다.
   복합 데이터형 : 기본 정수형과 부동 소수점형의 조합

   배열 : 같은 데이터형의 집합
   typeName arrayName[arraySize];
   */
  short month[12]; // 배열의 선언

  short month[12] = {1, 2, 3}; // 배열의 초기화
  // 12개의 배열크기를 가질건데 이 중에서 {1, 2, 3}을 씀으로써 3개만 쓸거라는 거야.

  cout << month[0] << endl; // 0번째 인덱스에 해당하는 1이 출력됨.
  /* 배열의 규칙
  1. 배열 원소에 대입할 값들을 콤마로 구분하여 중괄호로 묶어 선언한다.
   ex. short month[12] = {1, 2, 3}
  2. 초기화를 배열의 선언을 한 후에 할 수는 없다.
   ex. 선 선언 후 초기화 가 유지되기!
  3. 배열을 다른 배열에 통째로 대입할 수 없다.
   ex. short month[5] = { . . . } short year[12] = { . . . }
       year = month; // (X) 이럴 수는 없어!
  4. 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수 있다.
   ex. 위에서 12개의 원소를 선언했지만 3개의 원소만 초기화할 수 있다.
  5. 배열을 부분적으로 초기화하면, 나머지 원소들은 모두 0으로 설정한다.
  즉, 명시적으로 첫번째 원소만 0으로 초기화하면, 나머지 원소들은 모두 0으로 초기화된다.
   ex. {1, 2, 3}으로 0, 1, 2번째 인덱스만 초기화하면 3번째 인덱스부터 0으로 초기화된다.
  6. 배열을 초기화할 때 대괄호 속을 비워두면 컴파일러가 초기화 값의 개수를 헤아려
  배열 원소의 개수를 저장한다.
   ex. short month[] = {1, 2, 3} 이라고 하면 초기화한 배열의 크기가 3이므로 대괄호 속
   숫자가 없는 []는 자동으로 배열의 크기가 3을 갖는 것이다. 
   short month[] = {1, 2, 3} // 3번째 인덱스는 없으므로
   cout << month[3] << endl; // 알 수 없는 출력값이 나오게 된다.
  */

    return 0;
}

///////////////////////////////////////////////////////////////////////////

// <<<<<char 배열과 문자열>>>>>

#include <iostream>

using namespace std;

int main() {
    // 문자열 : 문자의 열.
//(I) 배열 그 자체. 하지만, 2%가 부족해.
    char a[5] = {'H', 'E', 'L', 'L', 'O'};

    cout << a << endl; 
    // HELLO 이 후에 의미없는 문자가 출력됨. -> null문자의 부재!
//(II) 완전한 배열 그 자체.
    char b[6] = {'H', 'E', 'L', 'L', 'O', '\0'}; 
    // null문자도 하나의 인덱스이므로 크기는 6으로 입력되겠지.

    cout << b << endl; // HELLO 만 출력됨.
//(III) 확실히 효율적인 배열.
    char c[] = "HELLO";

    cout << c << endl; // HELLO만 출력됨. ""는 null문자를 포함하고 있다!!!

    return 0;
}
