#include <iostream>

using namespace std;

int main() {

    //변수 선언 과정

    int val = 3;

    cout << &val << endl; // 변수 val에 대한 주소 값이 출력됨.

    /* C++ : 객체 지향 프로그래밍
    컴파일 시간이 아닌 실행 시간에 어떠한 결정을 내릴 수 있다.
    예를 들어, 배열 생성할 때,

    - 재래적 절차적 프로그래밍 : 배열의 크기가 미리 결정. 

ex) 7일 동안 배열의 크기가 20개인 배열을 사용하다가, 주 1번씩 200개의 배열이 필요
하다면, 200개의 크기를 갖는 배열을 항상 사용해야 하며 동시에 200개를 사용하지 않을
때는 180개의 메모리가 낭비되는 것. : 재래적, 절차적 프로그래밍

BUT,
    - 객체지향 프로그래밍 : 배열의 크기를 실행 시간에 결정.

ex) 20개의 크기를 갖는 배열이 필요하면 [20]을 선언하고, 200개가 간헐적으로 필요
하다면 [200]을 선언할 수 있다. : 객체지향 프로그래밍

    // 변수 선언 과정에서 Pointer의 요지 
    : 기존의 변수 선언 과정에서는 사용할 변수의 이름을 통해 그 변수를 관리했었지만,
    이제는 저장할 데이터를 다루는 주소에 이름을 붙인다고 이해하자.
    => 포인터 : 사용할 주소에 이름을 붙인다. 
    즉, 포인터는 포인터의 이름이 주소를 나타낸다. 
    // 간접값 연산자, 간접 참조 연산자 * 를 이용해 이를 나타낼 수 있다.
    */

   int *a; // C 스타일
   int* b; // C++ 스타일
   int* c, d; // c는 포인터 변수, d는 int형 변수로 사용된다.

   // 예제 

   int a = 6; // a를 변수로 지정하고 그 값을 6으로 초기화 (a는 수이고,)
   int* b; // int형에 포인터 변수 b를 선언, b는 그 자체로 주소를 나타냄. (b는 위치임)

   b = &a; // 주소 연산자 &를 사용해서 a의 주소값을 b에 삽입

   cout << "a의 값 " << a << endl; // 출력: a의 값 6
   cout << "*b의 값 " << *b << endl; // 출력: *b의 값 6, 
   // 포인터로 선언된 변수 *b는 값을 출력할 때, *b 로 출력하지만,

   cout << "a의 주소 " << &a << endl; // 출력: a의 주소값
   cout << "*b의 주소" << b << endl; // 출력: *b의 주소값
   // 주소로써 출력할 때는 그냥 b로 출력한다.

   *b = *b + 1;

   cout << "이제 a의 값은 " << a << endl; // 출력: 이제 a의 값은 7

    return 0;
}

/////////////////////////////////////////////////////////////////

// <new 연산자>

#include <iostream>

using namespace std;

int main() {

    /* new 연산자
1. 어떤 데이터형을 원하는지 new 연산자에게 알려주면 
2. new 연산자는 그에 알맞는 크기의 메모리 블록을 찾아내고,
3. 그 블록의 주소를 리턴합니다. 
*/

int* pointer = new int; 
/* 
new int는 int형 데이터를 지정할 수 있는 새로운 메모리가 필요하다고 알려주는 것
그러면 new연산자는 뒤따라오는 'int'를 보며 데이터형을
확인하고, 몇 byte가 필요한지 계산한다. 그러면 Window 10 기준, int형은 4 byte
이므로 4바이트가 계산될 것이다. 이제 4바이트를 저장할 수 있는 메모리 블록을 찾아
 그 주소를 포인터에게 리턴해서 초기화 해주게 되는 것이다.
*/
// (이전 수업 코드와 비교)
int a;
int* b = &a; // 포인터 변수 b에 a의 주소값을 대입하는 방식


/*
1) int* pointer = new int; 의 경우 'pointer'만 int형 변수에 접근할 수 있으나,
2) int a;  int* b = &a; 의 경우 b와 a의 주소를 통해서 접근할 수 있다. 

그렇다면, 1)에서 pointer는 지시하는 메모리의 이름이 없는데 어떻게 메모리에 접근할
수 있을까? 여기서 pointer가 '데이터의 객체'를 지시하고 있다 라고 표현한다. (객체 지향의 객체가 아님)
이러한 방식은 메모리 제어권을 사용자에게 줄 수 있다는 장점이 있다. 

이렇듯, 필요할 때 new를 사용해서 메모리를 대입하는 것은 C++의 강력한 장점 중 절반.
장점의 다른 절반은 사용한 메모리를 다시 메모리 폴의 영역으로 환수하는 delete 연산자이다.
*/

    // delete 연산자
    /*
    사용한 메모리를 다시 메모리 폴로 환수하는 것. 환수된 메모리는 프로그램의 다른 
    부분이 다시 사용할 수 있다. 
    */

   int* ps = new int; // new를 이용해서 포인터 변수 ps를 선언했고
   //메모리 사용       // 중간에 어떠한 코드를 사용하여 메모리를 사용한 후,
   delete ps; // ps에 할당된 메모리를 다시 프로그램에 다른 부분이 이 메모리를
   //사용할 수 있도록 프로그램에 반환해준다.
/*
 특징 : new를 사용한 후에는 반드시 delete를 사용해야 한다. 그렇지 않으면, 대입은
되었지만 나중에 사용되지 않은 메모리에 대해 누수가 발생할 수 있고 메모리 누수의 
규모가 너무 커지게 되면 프로그램이 먹통이 될 수 있다.

<delete를 사용하는 4가지 규칙>
1. new로 대입하지 않은 메모리는 delete로 해제할 수 없다. 
2. 같은 메모리 블록을 연달아 두 번 연속 delete로 해제할 수 없다.
3. new[]로 메모리를 대입할 경우 delete[]로 해제한다. 
4. 대괄호를 사용하지 않았다면 delete도 대괄호를 사용하지 않아야 한다.
*/

        return 0;

}

// 예제
#include <iostream>

int main() {

    using namespace std;

    double* p3 = new double[3]; // double형 데이터 3개를 저장할 수 있는 공간을 대입한다.
    p3[0] = 0.2;                // p3를 배열 이름처럼 취급한다. 이미 '공간'을 대입했기 때문에
    p3[1] = 0.5;                // p3[숫자] 로써 초기화할 수 있다.
    p3[2] = 0.8;
        
    cout << "p3[1] is " << p3[1] << ".\n"; 
    // 출력: p3[1] is 0.5

    p3 = p3 + 1; // 포인터를 증가시킨다. 포인터는 변수처럼 사용할 수 있기에 값을
    // 더하거나 뺄 수 있다. 만일, p3가 배열의 이름이었다면 틀린 문법이 되는거야.
    // +1 은 double형 데이터 공간 1개로 이해할 수 있다.

    cout << "Now p3[0] is " << p3[0] << " and "; 
    cout << "p3[1] is " << p3[1] << ".\n";
    // 출력: Now p3[0] is 0.5 and p3[1] is 0.8.

    p3 = p3 - 1; // 다시 시작 위치를 지시한다.
    delete[] p3; // p3의 배열 메모리를 해제한다. line 137에서 이미 []를 사용했으니,
                 // 여기서도 delete[]를 사용해야 한다.
    //cin.get();

    return 0;



    }
    
