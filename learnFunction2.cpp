// 함수와 구조체
/* 구조체와 배열의 차이 remind!
구조체 변수와 배열은 여러 개의 항목을 한 군데에 모아서 저장한다는 공통점을 지녔지만,
구조체 변수는 기본적으로 단위와 값을 가지는 보통의 변수처럼 행동한다. 그래서 배열처럼 배열의 첫번째
인자에 주소를 알려주는 방식이 아닌 함수의 온전한 값으로써 전달할 수 있다. 구조체를 값으로 전달하는 것에
단점이 있는데 구조체의 규모가 커질 경우에 구조체를 복사하는 시간이 걸리고 메모리의 요구가 높아져 성능 저하.
그렇기 때문에 구조체의 값이 아닌 구조체의 내용에 접근하는 포인터를 이용하는 방식을 선호한다. 
혹은 '참조'로 전달하는 방법이 있는데 이는 다음에 알려줄게.
 이때, 함수는 구조체의 원본이 아닌 복사본을 대상으로 작업한다는 점에 유의해야 한다.
*/
// <함수는 원본이 아닌 복사본을 대상으로 작업한다.>
#include <iostream>

using namespace std;

struct Time // 1. Time이라는 구조체에 변수로 hours와 mins를 선언
{
    int hours;
    int mins;
};

const int minsPerHr = 60; // 상수(const)로써 minsPerHr라는 이름으로 60을 선언한 이 후

// Time이라는 구조체를 이용해 다수의 시간과 분을 이용하여 더하고 출력하는 함수 제작

// <함수의 원형 제공>
Time sum(Time*, Time*);
void showTime(Time);

int main() {
    Time day1 = {5, 45};
    Time day2 = {4, 55};

    Time total = sum(&day1, &day2); 
    // day1과 day2의 주소를 argument로 하여 sum이라는 함수에 리턴값을 저장한다.

    cout << "이틀간 소요 시간 : ";
    showTime(total); // 그리고 total을 값으로써 전달 후 출력한다.
   
    return 0;
}

Time sum(Time* t1, Time* t2){ // 1. sum이라는 함수는 main 함수로부터 Time* t1과 t2를 받아
// 이 둘을 더하고 Time total을 리턴하는 함수로 만들 것이다.
/* 
구조체에 대해 멤버에 접근하기 위해서 L55,56와 같이 멤버 연산자인 '.(dot)'을 배운 적이 있다.
그런데 지금은 매개변수로 전달된 값이 구조체가 아니라 포인터 변수 이므로 '.(dot)'을 찍으면 안된다.
구조체의 주소에 대하여 그 멤버에 접근하고 싶을 때는 간접 멤버 연산자인 '->' 이 화살표 기호를 사용한다.

그래서, 구조체의 값에서 멤버에 접근하고 싶을 때는 연산자 '.' 을,
구조체의 주소에서 멤버에 접근하고 싶을 때는 '->' 를 사용해야 한다.
*/
    Time total;

    total.mins = (t1->mins + t2->mins) % minsPerHr;
    total.hours = t1->hours + t2->hours +
        (t1->mins + t2->mins) / minsPerHr;

    return total;
}

void showTime(Time t1) { // 이 시간을 출력하는 함수는 sum이라는 함수와 달리 구조체의 주소가 아니라
// 구조체의 값으로써 받아서 시간을 출력한다.
    cout << t1.hours << "시간, " << t1.mins << "분 입니다." << endl;
}

// 출력: 이틀간 소요 시간 : 10시간, 40분 입니다.

/////////////////////////////////////////////////////////////////////////////////////
// <재귀함수와 함수를 지시하는 포인터>
/*
재귀호출 : C++에서 함수는 자기 자신을 호출할 수 있다.
재귀함수 : 재귀호출을 할 수 있는 함수
새로 호출되는 함수도 자기 자신을 호출할 수 있으므로 호출의 연쇄를 끝내는 장치가 없다면 반복한다.
그러므로 재귀호출은 보통 if문과 함께 사용한다. 그 원형은 아래와 같은 형태를 보인다.

int main() {

void recurs(argumentList) { // 2. recurs라는 함수는 Code#1을 실행 후
        //Code#1
        if (condition) // 1. if문의 조건인 condition이 참이라면 
            recurs(argumentList); // 3. 자신을 다시 호출한다. 그리고 이 새로 호출된 recurs 역시
            // Code#1을 수행하고 condition이 참이라면 새로운 recurs를 호출하게 되는 것이다. 
        //Code#2
    } // 여기서 눈여겨볼 점은 재귀호출이 일어나는 동안 Code#2는 수행되지 않고 유보된다는 점이다.
    return 0;
}
*/

#include <iostream>

using namespace std;

void countDown(int);

int main() {

    countDown(5);
 
    return 0;
}

void countDown(int n) { // 1. 실행된 countDown은 int형 변수에 5가 저장되어 있을 것이고, 
    cout << "Counting . . . " << n << endl;
    if (n > 0)
    countDown(n - 1); // 2. 그 후, 4를 넣어 본인(countDown)을 호출한다.
    // 3. 그 다음, 3을 호출한다. 이를 반복하다가 countDown에게 0을 주게 될 수 있을텐데 이는 n > 0을
    // 어기게 되므로 if문은 중단된다.
    cout << n << "번째 재귀함수" << endl; // 4. if문이 중단되면서 몇번째 재귀함수인지 출력.
}
/* 출력:
Counting . . . 5
Counting . . . 4
Counting . . . 3
Counting . . . 2
Counting . . . 1
Counting . . . 0 // 0부터는 재귀호출이 일어나지 않음
0번째 재귀함수 // 0부터 역순으로 #Code2의 부분이 실행됨을 알 수 있다.
1번째 재귀함수
2번째 재귀함수
3번째 재귀함수
4번째 재귀함수
5번째 재귀함수
*/

/////////////////////////////////////////////////////////////////////////////////////
// <함수를 지시하는 포인터>

#include <iostream>

using namespace std;

int func(int);

int main() {
// 함수를 지시하는 포인터
// 어떠한 함수에 함수의 주소를 매개변수로 넘겨주는 경우 유용하게 사용할 수 있다.
/*
1. 함수의 주소를 얻는다. : 함수가 선언되어 있을 때 뒤에 붙은 괄호를 빼고 이름만 사용하면 
그 함수의 주소를 쉽게 얻을 수 있다.
2. 함수를 지시하는 포인터를 선언한다.
3. 함수를 지시하는 포인터를 사용하여 그 함수를 호출한다.
*/
//  cout << func << endl; // 1번의 규칙의 예시, 출력: func 함수의 주소값이 출력됨

/* 
어떤 데이터형을 지시하는 포인터를 선언할 때 그 포인터에게 정확하게 어떤 데이터형을 지시하는지
포인터에게 알려주듯이 함수 역시도 함수를 지정하는 포인터를 선언할 때에도 그 포인터에게 지시하는
함수의 데이터형을 지정해줘야 한다. 지금 int형 매개변수를 가지는 int형 함수인 func를 지정하는
포인터를 만들고 싶으니까 아래와 같이 int형 포인터를 정의한다.
*/

int (*pf)(int); //(int)형 매개변수를 가진 포인터를 int형으로 정의한다.
pf = func; // 포인터에게 함수의 주소를 저장하면 된다.
// pf는 함수를 지시하게 되었으므로 pf를 이용하여 함수를 호출할 수 있다.

cout << (*pf)(3) << endl; // 입력받은 매개변수 3에 1을 더하여 4가 출력된다.

    return 0;
}

int func(int n) {
    
    return n + 1;
}
