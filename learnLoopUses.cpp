// <반복문의 활용> 

//배열 기반 반복문
#include <iostream>
using namespace std;

int main() {

    int a[5] = {1, 3, 5, 7, 9};
// 1. <알고 있던 반복문>
    for (int i = 0; i < 5; i++) {
        cout << a[i]; // 출력: 13579
    }   cout << "\n";

// 2. <배열 기반 반복문>
    for (int i : a) {
         // for (출력하고자 하는 데이터형과 같은 데이터형 : 배열의 이름) {}
        cout << i; // 출력: 13579
    } 
    // i는 반복이 실행되지 않을때 가장 첫번째 원소인 1을 의미하게 되고 실행할 때마다
    // 그 다음 원소를 가리키게 됨. 단순히 i를 출력함으로써 배열 모두를 표현가능.
/* 
1번의 반복문의 경우 카운터에 조건을 달아주어 배열을 끝마칠 수 있지만,
2번의 반복문의 경우 배열의 사이즈를 끝까지 출력하기 때문에 만약, 배열의 사이즈보다
적은 수가 초기화 되어있다면 남은 값인 0도 모두 초기화가 될 것임. 예시는 바로 아래 코드
*/
    int r[10] = {1, 3, 5, 7, 9};
    for (int r : a) {
        cout << r; // 출력: 1357900000
    }

    // <중첩 루프>, 반복문의 반복 -> 2차원 배열에서 높은 활용도, 행과 열이 존재
    
    int temp[4][5]; // temp라는 배열은 4개의 원소를 갖고 있고(가로),
     {              // 그 원소들은 각각 5개씩의 원소를 더 가짐(세로로)
        {1, 2, 3, 4, 5},  
        {11, 22, 33, 44, 55},
        {111, 222, 333, 444, 555},
        {1111, 2222, 3333, 4444, 5555}
    } // 행마다 콤마 찍어주는거 필수여야 해
                
    for (int row = 0; row < 5; row++) {
        for (int col = 0; col < 5; col++) {
            cout << temp[row][col] << " ";
        }
        cout << "\n";
    }
/*
Line 42,43에서 int row가 0일 때, col이 0부터 5보다 작아질 때까지 1씩 증가하며 
Line 44의 cout을 반복하게 된다. row가 0으로 고정된 상태에서 [0,0], [0,1], ...
[0,4] 모두 출력하면 row가 1 증가하여 다시 [1,0], ... ,[1,4] 모두 출력하며 반복.
   
  출력: 1 2 3 4 5
        11 22 33 44 55
        111 222 333 444 555
        1111 2222 3333 4444 5555
*/ 
    return 0;
}
